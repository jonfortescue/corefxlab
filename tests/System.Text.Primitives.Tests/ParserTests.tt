<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#
	string[] utfEncodings = new string[] {"8", "16"};

	Type[] unsignedTypes = new Type[] { typeof(byte), typeof(ushort), typeof(uint), typeof(ulong) };
	string[] unsignedPrimitives = new string[] { "byte", "ushort", "uint", "ulong" };
	
	Type[] signedTypes = new Type[] { typeof(sbyte), typeof(short), typeof(int), typeof(long) };
	string[] signedPrimitives = new string[] { "sbyte", "short", "int", "long" };

	Type[] floatingPointTypes = new Type[] { typeof(float), typeof(double) };
	string[] floatingPointPrimitives = new string[] { "float", "double" };
	
#>
// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in ParserTests.tt.

using System.Runtime.InteropServices;
using System.Text;
using Xunit;

namespace System.Text.Primitives.Tests
{
	public class ParserTests
    {
        private byte[] UtfEncode(string s, bool utf16)
        {
            if (utf16)
                return Encoding.Unicode.GetBytes(s);
            else
                return Encoding.UTF8.GetBytes(s);
        }

<#
		for (int i = 0; i < unsignedTypes.Length; i++)
		{
			string capitalizedPrimitive = (char)(unsignedPrimitives[i][0] - 32) + unsignedPrimitives[i].Remove(0,1);

			var minValue = unsignedTypes[i].GetField("MinValue").GetValue(null);
			var maxValue = unsignedTypes[i].GetField("MaxValue").GetValue(null);
			int minValueLength = minValue.ToString().Length;
			int maxValueLength = maxValue.ToString().Length;

			string maxString = maxValue.ToString();

			char overflowChar = (char)(maxString[maxString.Length - 1] + 1);
			string overflowValue = maxString.Remove(maxString.Length - 1) + overflowChar;

			string midValue = maxString.Remove(0,1);
		
			StringBuilder randValueSB = new StringBuilder();
			Random r = new Random(55); // a seed is used so that the same "random" values are always generated
									   // good for test consistency
			foreach (char c in midValue)
			{
				if (c > '5')
				{
					randValueSB.Append((char)(c - r.Next(0,5)));
				}
				else
				{
					randValueSB.Append((char)(c + r.Next(0,4)));
				}
			}
			string randValue = randValueSB.ToString();

#>
		#region <#= unsignedPrimitives[i] #>

		[Theory]
        [InlineData("<#= midValue #>", true, 0, <#= midValue #>, <#= midValue.Length #>)]
        [InlineData("blahblahh<#= randValue #>", true, 9, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= randValue #>abhced", true, 0, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength #>)] // min value
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength #>)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // overflow test
        public unsafe void ParseCustomCultureByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= unsignedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = new FormattingData(new byte[] { 48 }, new byte[] { 49 }, new byte[] { 50 }, new byte[] { 51 }, new byte[] { 52 },
                new byte[] { 53 }, new byte[] { 54 }, new byte[] { 55 }, new byte[] { 56 }, new byte[] { 57 }, new byte[] { 46 }, null,
                new byte[] { 73, 110, 102, 105, 110, 105, 116, 121 }, new byte[] { 45 }, new byte[] { 43 }, new byte[] { 78, 97, 78 }, new byte[] { 69 }, new byte[] { 101 },
                FormattingData.Encoding.Utf8, (byte)FormattingData.ParsingStates.PARSING);
            Format.Parsed nf = new Format.Parsed('G');
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

<#
			foreach (var utfEncoding in utfEncodings)
			{
			
				int utfByteFactor = (utfEncoding == "8" ? 1 : 2);
#>
		[Theory]
        [InlineData("<#= midValue #>", true, 0, <#= midValue #>, <#= midValue.Length * utfByteFactor #>)]
        [InlineData("blahblahh<#= randValue #>", true, <#= 9 * utfByteFactor #>, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("<#= randValue #>abhced", true, 0, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength * utfByteFactor #>)] // min value
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength * utfByteFactor #>)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= unsignedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf<#= utfEncoding #>;
            Format.Parsed nf = new Format.Parsed('G');
            bool result = InvariantParser.TryParse(UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("<#= midValue #>", true, 0, <#= midValue #>, <#= midValue.Length * utfByteFactor #>)]
        [InlineData("blahblahh<#= randValue #>", true, <#= 9 * utfByteFactor #>, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("<#= randValue #>abhced", true, 0, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength * utfByteFactor #>)] // min value
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength * utfByteFactor #>)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= unsignedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= unsignedPrimitives[i] #> parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            FormattingData fd = FormattingData.InvariantUtf<#= utfEncoding #>;
            Format.Parsed nf = new Format.Parsed('G');
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, textBytes.Length, fd, nf, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

<#
			}
#>
		#endregion

<#
		}
#>
<#
		for (int i = 0; i < signedTypes.Length; i++)
		{
			string capitalizedPrimitive = (char)(signedPrimitives[i][0] - 32) + signedPrimitives[i].Remove(0,1);

			var minValue = signedTypes[i].GetField("MinValue").GetValue(null);
			var maxValue = signedTypes[i].GetField("MaxValue").GetValue(null);
			int minValueLength = minValue.ToString().Length;
			int maxValueLength = maxValue.ToString().Length;

			string maxString = maxValue.ToString();
			string minString = minValue.ToString();

			char overflowChar = (char)(maxString[maxString.Length - 1] + 1);
			string overflowValue = maxString.Remove(maxString.Length - 1) + overflowChar;
			
			char underflowChar = (char)(minString[minString.Length - 1] + 1);
			string underflowValue = minString.Remove(minString.Length - 1) + underflowChar;

			string midValue = maxString.Remove(0,1);
			string midMinValue = minString.Remove(1,1);
		
			StringBuilder randValueSB = new StringBuilder();
			Random r = new Random(123); // a seed is used so that the same "random" values are always generated
									   // good for test consistency
			foreach (char c in midValue)
			{
				if (c > '5')
				{
					randValueSB.Append((char)(c - r.Next(0,5)));
				}
				else
				{
					randValueSB.Append((char)(c + r.Next(0,4)));
				}
			}
			string randValue = randValueSB.ToString();

#>
		#region <#= signedPrimitives[i] #>

		[Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh<#= midValue #>", true, 9, <#= midValue #>, <#= midValue.Length #>)]
        [InlineData("<#= randValue #>abcdefg", true, 0, <#= randValue #>, <#= randValue.Length #>)]
        [InlineData("The smallest of this type is <#= minValue #>.", true, 29, <#= minValue #>, <#= minValueLength #>)]
        [InlineData("Letthem<#= midMinValue #>eatcake", true, 7, <#= midMinValue #>, <#= midMinValue.Length #>)]
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength #>)] // max
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength #>)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseCustomCultureByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = new FormattingData(new byte[] { 48 }, new byte[] { 49 }, new byte[] { 50 }, new byte[] { 51 }, new byte[] { 52 },
                new byte[] { 53 }, new byte[] { 54 }, new byte[] { 55 }, new byte[] { 56 }, new byte[] { 57 }, new byte[] { 46 }, null,
                new byte[] { 73, 110, 102, 105, 110, 105, 116, 121 }, new byte[] { 45 }, new byte[] { 43 }, new byte[] { 78, 97, 78 }, new byte[] { 69 }, new byte[] { 101 },
                FormattingData.Encoding.Utf8, (byte)FormattingData.ParsingStates.PARSING);
            Format.Parsed nf = new Format.Parsed('G');
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void ParseCustomCultureThaiByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = new FormattingData(new byte[] { 0xe0, 0xb9, 0x90 }, new byte[] { 0xe0, 0xb9, 0x91 }, new byte[] { 0xe0, 0xb9, 0x92 },
                new byte[] { 0xe0, 0xb9, 0x93 }, new byte[] { 0xe0, 0xb9, 0x94 }, new byte[] { 0xe0, 0xb9, 0x95 }, new byte[] { 0xe0, 0xb9, 0x96 },
                new byte[] { 0xe0, 0xb9, 0x97 }, new byte[] { 0xe0, 0xb9, 0x98 }, new byte[] { 0xe0, 0xb9, 0x99 }, new byte[] { 0xE0, 0xB8, 0x88, 0xE0, 0xB8, 0x94 }, null,
                new byte[] { 0xE0, 0xB8, 0xAA, 0xE0, 0xB8, 0xB4, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x87, 0xE0, 0xB8, 0x97, 0xE0, 0xB8, 0xB5, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x83,
                    0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0x8D, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x82, 0xE0, 0xB8, 0x95, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0xA5, 0xE0,
                    0xB8, 0xB7, 0xE0, 0xB8, 0xAD, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0x81, 0xE0, 0xB8, 0xB4, 0xE0, 0xB8, 0x99 },
                new byte[] { 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x9A }, new byte[] { 43 }, new byte[] { 0xE0, 0xB9, 0x84, 0xE0, 0xB8, 0xA1, 0xE0, 0xB9, 0x88, 0xE0, 0xB9,
                    0x83, 0xE0, 0xB8, 0x8A, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x95, 0xE0, 0xB8, 0xB1, 0xE0, 0xB8, 0xA7, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x82 },
                new byte[] { 69 }, new byte[] { 101 },
                FormattingData.Encoding.Utf8, (byte)FormattingData.ParsingStates.PARSING);
            Format.Parsed nf = new Format.Parsed('G');
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

<#
			foreach (var utfEncoding in utfEncodings)
			{
				int utfByteFactor = (utfEncoding == "8" ? 1 : 2);
#>
		[Theory]
        [InlineData("111", true, 0, 111, <#= 3 * utfByteFactor #>)]
        [InlineData("blahblahh<#= midValue #>", true, <#= 9 * utfByteFactor #>, <#= midValue #>, <#= midValue.Length * utfByteFactor #>)]
        [InlineData("<#= randValue #>abcdefg", true, 0, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("The smallest of this type is <#= minValue #>.", true, <#= 29 * utfByteFactor #>, <#= minValue #>, <#= minValueLength * utfByteFactor #>)]
        [InlineData("Letthem<#= midMinValue #>eatcake", true, <#= 7 * utfByteFactor #>, <#= midMinValue #>, <#= midMinValue.Length * utfByteFactor #>)]
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength * utfByteFactor #>)] // max
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength * utfByteFactor #>)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf<#= utfEncoding #>ByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf<#= utfEncoding #>;
            Format.Parsed nf = new Format.Parsed('N');
            bool result = InvariantParser.TryParse(UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData("111", true, 0, 111, <#= 3 * utfByteFactor #>)]
        [InlineData("blahblahh<#= midValue #>", true, <#= 9 * utfByteFactor #>, <#= midValue #>, <#= midValue.Length * utfByteFactor #>)]
        [InlineData("<#= randValue #>abcdefg", true, 0, <#= randValue #>, <#= randValue.Length * utfByteFactor #>)]
        [InlineData("The smallest of this type is <#= minValue #>.", true, <#= 29 * utfByteFactor #>, <#= minValue #>, <#= minValueLength * utfByteFactor #>)]
        [InlineData("Letthem<#= midMinValue #>eatcake", true, <#= 7 * utfByteFactor #>, <#= midMinValue #>, <#= midMinValue.Length * utfByteFactor #>)]
        [InlineData("<#= maxValue #>", true, 0, <#= maxValue #>, <#= maxValueLength * utfByteFactor #>)] // max
        [InlineData("<#= minValue #>", true, 0, <#= minValue #>, <#= minValueLength * utfByteFactor #>)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue #>", false, 0, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue #>", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf<#= utfEncoding #>ByteStarTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= signedPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= signedPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf<#= utfEncoding #>;
            Format.Parsed nf = new Format.Parsed('N');

            byte[] textBytes = UtfEncode(text, <#= utfEncoding != "8" ? "true" : "false" #>);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, textBytes.Length, fd, nf,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

<#
			}
#>
		#endregion

<#
		}
#>
<#
		for (int i = 0; i < floatingPointTypes.Length; i++)
		{
			string capitalizedPrimitive = (char)(floatingPointPrimitives[i][0] - 32) + floatingPointPrimitives[i].Remove(0,1);

			var minValue = floatingPointTypes[i].GetField("MinValue").GetValue(null);
			var maxValue = floatingPointTypes[i].GetField("MaxValue").GetValue(null);
			int minValueLength = minValue.ToString().Length;
			int maxValueLength = maxValue.ToString().Length;

			string maxString = maxValue.ToString();
			int eIndex = maxString.IndexOf('E');
			char oneLess = (char)(maxString[eIndex - 1] - 1);
			maxString = maxString.Remove(eIndex-1,1).Insert(eIndex-1,oneLess.ToString());

			string minString = minValue.ToString();
			eIndex = minString.IndexOf('E');
			oneLess = (char)(minString[eIndex - 1] - 1);
			minString = minString.Remove(eIndex-1,1).Insert(eIndex-1,oneLess.ToString());

			char overflowChar = (char)(maxString[maxString.Length - 1] + 1);
			string overflowValue = maxString.Remove(maxString.Length - 1) + overflowChar;

			string floatString = floatingPointPrimitives[i] == "float" ? "f" : "";

#>
		#region <#= floatingPointPrimitives[i] #>

		[Theory]
        [InlineData(".1728", true, 0, 0.1728<#= floatString #>, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110<#= floatString #>, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7<#= floatString #>, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001<#= floatString #>, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12<#= floatString #>, 7)]
        [InlineData("1E-8", true, 0, 1e-8<#= floatString #>, 4)]
        [InlineData("<#= minString #>", true, 0, <#= minString #><#= floatString #>, <#= minString.Length #>)] // min value
        [InlineData("<#= maxString #>", true, 0, <#= maxString #><#= floatString #>, <#= maxString.Length #>)] // max value
        [InlineData("Infinity", true, 0, <#= floatingPointPrimitives[i] #>.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, <#= floatingPointPrimitives[i] #>.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, <#= floatingPointPrimitives[i] #>.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public void ParseUtf8ByteArrayTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= floatingPointPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= floatingPointPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf8;
            Format.Parsed nf = new Format.Parsed('N');
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		[Theory]
        [InlineData(".1728", true, 0, 0.1728<#= floatString #>, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110<#= floatString #>, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7<#= floatString #>, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001<#= floatString #>, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12<#= floatString #>, 7)]
        [InlineData("1E-8", true, 0, 1e-8<#= floatString #>, 4)]
        [InlineData("<#= minString #>", true, 0, <#= minString #><#= floatString #>, <#= minString.Length #>)] // min value
        [InlineData("<#= maxString #>", true, 0, <#= maxString #><#= floatString #>, <#= maxString.Length #>)] // max value
        [InlineData("Infinity", true, 0, <#= floatingPointPrimitives[i] #>.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, <#= floatingPointPrimitives[i] #>.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, <#= floatingPointPrimitives[i] #>.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarTo<#= capitalizedPrimitive #>(string text, bool expectSuccess, int index, <#= floatingPointPrimitives[i] #> expectedValue, int expectedBytesConsumed)
        {
            <#= floatingPointPrimitives[i] #> parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf8;
            Format.Parsed nf = new Format.Parsed('N');

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, textBytes.Length, fd, nf,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

<#
		}
#>
		#region bool
		
        [Theory]
        [InlineData("blahblahhTrue", true, 9, true, 4)]
        [InlineData("trueacndasjfh", true, 0, true, 4)]
        [InlineData("LetthemFALSEeatcake", true, 7, false, 5)]
        [InlineData("false", true, 0, false, 5)]
        [InlineData("FaLsE", true, 0, false, 5)]
        [InlineData("0", true, 0, false, 1)]
        [InlineData("1", true, 0, true, 1)]
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        public void ParseUtf8ByteArrayToBool(string text, bool expectSuccess, int index, bool expectedValue, int expectedBytesConsumed)
        {
            bool parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf8;
            Format.Parsed nf = new Format.Parsed('N');
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, fd, nf, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

        [Theory]
        [InlineData("blahblahhTrue", true, 9, true, 4)]
        [InlineData("trueacndasjfh", true, 0, true, 4)]
        [InlineData("LetthemFALSEeatcake", true, 7, false, 5)]
        [InlineData("false", true, 0, false, 5)]
        [InlineData("FaLsE", true, 0, false, 5)]
        [InlineData("0", true, 0, false, 1)]
        [InlineData("1", true, 0, true, 1)]
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        public unsafe void ParseUtf8ByteStarToBool(string text, bool expectSuccess, int index, bool expectedValue, int expectedBytesConsumed)
        {
            bool parsedValue;
            int bytesConsumed;
            FormattingData fd = FormattingData.InvariantUtf8;
            Format.Parsed nf = new Format.Parsed('N');

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, textBytes.Length, fd, nf,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

        #endregion

		#region decimal

        [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.25abcdefg", true, 0, 98.25, 6)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1111111111111111111111111111111111111111111111111111111111", false, 0, 0, 0)] // overflow test
        public void ParseUtf8ByteArrayToDecimal(string text, bool expectSuccess, int index, decimal expectedValue, int expectedBytesConsumed)
        {
            decimal parsedValue;
            int bytesConsumed;
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

        [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.25abcdefg", true, 0, 98.25, 6)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1111111111111111111111111111111111111111111111111111111111", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToDecimal(string text, bool expectSuccess, int index, decimal expectedValue, int expectedBytesConsumed)
        {
            byte[] utf8Array = UtfEncode(text, false);

            decimal parsedValue;
            int bytesConsumed;
            fixed (byte* arrayPointer = utf8Array)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, utf8Array.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

        #endregion

        #region uri
        [Theory]
        [InlineData("http://www.example.com/", true, 0, "http://www.example.com/", 23)]
        [InlineData("https://www.example.org/important.php?true=true", true, 0, "https://www.example.org/important.php?true=true", 47)]
        [InlineData("http://msw", true, 0, "http://msw", 10)]
        [InlineData("ftp://example.org", true, 0, "ftp://example.org", 17)]
        [InlineData("file:///C:\\Users", true, 0, "file:///C:\\Users", 16)]
        [InlineData("C:\\Users", true, 0, "C:\\Users", 8)]
        [InlineData("rtsp://192.168.1.1", true, 0, "rtsp://192.168.1.1", 18)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", true, 15, "http://www.example.org", 22)]
        [InlineData("http://&5", false, 0, "", 0)]
        [InlineData("(*)$#*(", false, 0, "", 0)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", false, 4, "", 0)] // bad index
        [InlineData("197", false, 0, "", 0)]
        [InlineData("://////888.4.4.4", false, 0, "", 0)]
        public void ParseUtf8ByteArrayToUri(string text, bool expectSuccess, int index, string expectedValue, int expectedBytesConsumed)
        {
            Uri parsedValue;
            int bytesConsumed;
            bool result = InvariantParser.TryParse(UtfEncode(text, false), index, out parsedValue, out bytesConsumed);


            Assert.Equal(expectSuccess, result);
            if (expectedValue != "")
                Assert.Equal(new Uri(expectedValue), parsedValue);
            else
                Assert.Equal(null, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

        [Theory]
        [InlineData("http://www.example.com/", true, 0, "http://www.example.com/", 23)]
        [InlineData("https://www.example.org/important.php?true=true", true, 0, "https://www.example.org/important.php?true=true", 47)]
        [InlineData("http://msw", true, 0, "http://msw", 10)]
        [InlineData("ftp://example.org", true, 0, "ftp://example.org", 17)]
        [InlineData("file:///C:\\Users", true, 0, "file:///C:\\Users", 16)]
        [InlineData("C:\\Users", true, 0, "C:\\Users", 8)]
        [InlineData("rtsp://192.168.1.1", true, 0, "rtsp://192.168.1.1", 18)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", true, 15, "http://www.example.org", 22)]
        [InlineData("http://&5", false, 0, "", 0)]
        [InlineData("(*)$#*(", false, 0, "", 0)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", false, 4, "", 0)] // bad index
        [InlineData("197", false, 0, "", 0)]
        [InlineData("://////888.4.4.4", false, 0, "", 0)]
        public unsafe void ParseUtf8ByteStarToUri(string text, bool expectSuccess, int index, string expectedValue, int expectedBytesConsumed)
        {
            Uri parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = InvariantParser.TryParse(arrayPointer, index, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                if (expectedValue != "")
                    Assert.Equal(new Uri(expectedValue), parsedValue);
                else
                    Assert.Equal(null, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
        #endregion
	}
}